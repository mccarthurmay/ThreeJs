<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Portfolio - Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            display: none;
        }
        #coordinates {
            display: none;
        }
        #spotify-player {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 250px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        #spotify-player.minimized {
            width: 40px;
            height: 40px;
            padding: 0;
            background: transparent;
            backdrop-filter: none;
            overflow: hidden;
        }
        #spotify-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: background 0.2s;
        }
        #spotify-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        #spotify-iframe {
            transition: opacity 0.3s ease;
        }
        #spotify-player.minimized #spotify-iframe {
            opacity: 0;
            pointer-events: none;
        }
        .sign-label {
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            white-space: normal;
            max-width: 300px;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Controls:</strong><br>
        W - Move forward<br>
        S - Move backward<br>
        A - Turn left<br>
        D - Turn right<br>
        SPACE - Jump<br>
        Middle Mouse - Bird's Eye View<br>
        Scroll - Zoom (bird's eye)<br>
        R - Return to player<br>
        <br>
        <span id="camera-mode-text">Walk around the planet!</span>
    </div>

    <div id="coordinates">
        Position: (0, 0, 0)
    </div>

    <div id="spotify-player">
        <button id="spotify-toggle" onclick="toggleSpotify(event)">−</button>
        <iframe id="spotify-iframe" style="border-radius:12px"
                width="100%"
                height="180"
                scrolling="no"
                frameBorder="0"
                allow="autoplay"
                src="https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/vinceguaraldiquintet/sets/a-charlie-brown-thanksgiving&color=%23000000&auto_play=false&hide_related=false&show_comments=false&show_user=true&show_reposts=false&show_teaser=false">
        </iframe>
    </div>

    <div id="loading-screen">
        <div id="loading-content">
            <h1>Max's World</h1>
            <div id="loading-bar-container">
                <div id="loading-bar"></div>
            </div>
            <p id="loading-text">Loading... 0%</p>
            <div id="controls-info">
                <h3>Controls</h3>
                <p><strong>WASD</strong> - Move</p>
                <p><strong>Space</strong> - Jump</p>
                <p><strong>Mouse</strong> - Look around</p>
                <p><strong>Middle Mouse</strong> - Bird's eye view</p>
                <p><strong>R</strong> - Return to player</p>
                <p><strong>X</strong> - Reset to spawn</p>
            </div>
        </div>
    </div>

    <div id="intro-screen">
        <div id="intro-content">
            <h1>Max's World</h1>
            <p id="enter-prompt">Press ENTER to begin</p>
        </div>
    </div>

    <style>
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            transition: opacity 1s ease-out;
        }

        #loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #loading-content {
            text-align: center;
            color: white;
            max-width: 600px;
        }

        #loading-content h1 {
            font-size: 4em;
            margin-bottom: 40px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        #loading-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        #loading-text {
            font-size: 1.2em;
            margin-bottom: 40px;
            color: rgba(255, 255, 255, 0.7);
        }

        #controls-info {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #controls-info h3 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #8BC34A;
        }

        #controls-info p {
            font-size: 1.1em;
            margin: 10px 0;
            color: rgba(255, 255, 255, 0.8);
        }

        #controls-info strong {
            color: white;
            min-width: 120px;
            display: inline-block;
        }

        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
            opacity: 0;
            transition: opacity 1s ease-out;
        }

        #intro-screen.visible {
            opacity: 1;
        }

        #intro-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #intro-content {
            text-align: center;
            color: white;
        }

        #intro-content h1 {
            font-size: 4em;
            margin-bottom: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        #enter-prompt {
            font-size: 1.5em;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.Fog(0x0a0a1a, 20, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // CSS2D Renderer for sign labels
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x808080, 3.0); // Increased for brighter nighttime
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 3.0); // Increased from 2.0 to 3.0 for brighter sunlight
        sunLight.position.set(10, 10, 10);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -30;
        sunLight.shadow.camera.right = 30;
        sunLight.shadow.camera.top = 30;
        sunLight.shadow.camera.bottom = -30;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 150;
        sunLight.shadow.mapSize.width = 8192;
        sunLight.shadow.mapSize.height = 8192;
        sunLight.shadow.bias = -0.0001; // Reduced bias for tighter contact shadows
        sunLight.shadow.normalBias = 0.02; // Increased to prevent self-shadowing artifacts
        sunLight.shadow.radius = 2; // Slightly softer shadows

        // Planet
        const planetRadius = 16;

        const planetGroup = new THREE.Group();
        planetGroup.add(sunLight);
        scene.add(planetGroup);

        // Store sign labels and their world positions for proximity detection
        const signLabels = [];

        // Store spawn cube reference
        let spawnCube = null;

        // Bird's eye camera controls
        let detachedCamera = false;
        let birdEyeDistance = 25; // Distance from origin in bird's eye view
        let birdEyeTilt = Math.PI / 6; // 30 degree tilt from top-down (0 = straight down, PI/2 = horizontal)
        let birdEyeRotation = new THREE.Quaternion(); // Independent rotation for bird's eye view
        let isDragging = false;

        // Saved state for returning from bird's eye view
        let savedPlanetRotation = new THREE.Quaternion();
        let savedCharacterRotation = 0;
        let savedCharacterPosition = new THREE.Vector3();

        // Sign content data
        const signData = {
            'sign1': 'Press enter to teleport back to your crash landing.',
            'sign2': 'These were the base for me to grow my creative interests...',
            'sign3': 'Walk left to know my story, right for (the start of) my professional journey.', // second
            'sign4': 'Other interests/hobbies.',
            'sign5': 'This way to see my hobbies/passions.',
            'sign6': 'Then, I started exploring the adirondacks.',
            "sign7": "WASD to move.", // Start sign
            'sign8': 'I was born in Guangzhou, China. I only lived there for a short 5 years. We left for the US, my mom making a new life and my dad returning home.', // third
            'sign9': 'I had a great time growing up. My parents didn\'t like each other too much, but they did the best they could. Timeless memories were made with the friends I met, and now a few will remain life-long.', // left 2
            'sign10': 'Then, I took a leap of faith going to Colorado College, a small liberal arts school in Colorado Springs. I\'m grateful for who I am today, and it\'s safe to say that these past 3 years have been incredibly transformative. I wouldn\'t be who I am today if not for the people I surrounded myself with and the passions I chose to pursue.', // left three
            'sign11': 'I am now a junior.',
            'sign12': "I'm currently doing research for a professor at the Colorado School of Mines regarding the stigma around mental health.",
            'sign13': "Here's a list of my project: Super mario A* and Theta* Pathfinder in C, Top-Down Adventure Game in Java, Stock Tracker using Alpaca. (a gallery area)",
            'sign14': 'Dabbling in Cybersecurity: Certification in eJPT, working on the PNPT.',
            'sign15': 'Future projects: TBD',
            'sign16': '1',
            'sign17': '2',
            'sign18': '3',
            'sign19': '4',
            'sign20': 'My love of the outdoors started with kayaking the lakes of NY.',
            'sign21': 'Click the sign to see photography portfolio.',
            'sign22': 'Click the sign to see my videography portfolio.',
            'sign23': 'Thank You for Visiting!',
            'sign24': 'Space to Jump',
            'sign25': 'Middle mouse to enter bird\'s eye view. R to return to player.',
            'sign26': 'X to reset entirely if you\'re in a pickle.'
        };

        // Load the Blender world model
        const planetLoader = new GLTFLoader();
        planetLoader.load('world-only.glb',
            // onLoad callback
            function(gltf) {
            const planet = gltf.scene;

            planet.traverse((child) => {
                if (child.isMesh) {
                    const name = child.name.toLowerCase();
                    const isGround = name.includes('ground');

                    child.castShadow = !isGround;
                    child.receiveShadow = true;

                    // Log all meshes to help debug spawn detection
                    if (name.includes('spawn')) {
                        console.log(`>>> SPAWN MESH FOUND: "${child.name}" (lowercase: "${name}")`);
                    }

                    // Check if this is the spawn cube (check exact name or contains 'spawn')
                    if (name === 'spawn' || name.includes('spawn')) {
                        spawnCube = child;
                        console.log(`Found spawn cube: "${child.name}" (original: "${child.name}") at local position:`, child.position);
                    }

                    // Check if this is a sign
                    if (child.name.toLowerCase().includes('sign')) {
                        const signName = child.name.toLowerCase();
                        const signText = signData[signName];

                        // Only create label if sign has text defined
                        if (signText) {
                            // Create label div
                            const labelDiv = document.createElement('div');
                            labelDiv.className = 'sign-label';
                            labelDiv.textContent = signText;

                            // Create CSS2DObject
                            const label = new CSS2DObject(labelDiv);
                            label.visible = false; // Hidden by default

                            // Get world position of the sign for proximity checking
                            child.updateWorldMatrix(true, false);
                            const signWorldPos = new THREE.Vector3();
                            child.getWorldPosition(signWorldPos);

                            // Position label directly on the sign (centered on the mesh)
                            label.position.set(0, -10, 0);
                            child.add(label);

                            // Store reference for proximity checking
                            signLabels.push({
                                labelObject: label,
                                mesh: child,
                                worldPos: signWorldPos
                            });

                            console.log(`Created label for ${child.name}: "${signText}"`);
                        } else {
                            console.log(`Skipped label for ${child.name}: no text defined`);
                        }
                    }
                }
            });

            planetGroup.add(planet);
            console.log('Blender world model loaded successfully');

            // Rotate planet so spawn cube is at character position (0, y, 0)
            console.log('Checking for spawn cube...', spawnCube ? 'Found!' : 'Not found');
            if (spawnCube) {
                // Get the spawn cube's position within the planet's local coordinate system
                // We need to traverse up to find the position in planet's space
                let spawnLocalPos = new THREE.Vector3();
                spawnCube.getWorldPosition(spawnLocalPos);

                // Convert world position to planet's local space
                const planetWorldToLocal = new THREE.Matrix4();
                planetWorldToLocal.copy(planetGroup.matrixWorld).invert();
                spawnLocalPos.applyMatrix4(planetWorldToLocal);

                console.log(`Spawn cube position in planet space: (${spawnLocalPos.x.toFixed(2)}, ${spawnLocalPos.y.toFixed(2)}, ${spawnLocalPos.z.toFixed(2)})`);

                // Normalize the position to get direction on the sphere surface
                const spawnDirection = spawnLocalPos.clone().normalize();

                // We want this direction to point "up" (0, 1, 0) after rotation
                // Calculate the rotation needed
                const upVector = new THREE.Vector3(0, 1, 0);
                const rotationAxis = new THREE.Vector3().crossVectors(spawnDirection, upVector).normalize();
                const rotationAngle = Math.acos(spawnDirection.dot(upVector));

                console.log(`Rotation angle: ${(rotationAngle * 180 / Math.PI).toFixed(2)} degrees`);
                console.log(`Rotation axis: (${rotationAxis.x.toFixed(2)}, ${rotationAxis.y.toFixed(2)}, ${rotationAxis.z.toFixed(2)})`);

                // Apply the rotation
                const spawnRotation = new THREE.Quaternion();
                spawnRotation.setFromAxisAngle(rotationAxis, rotationAngle);
                planetGroup.quaternion.copy(spawnRotation);

                // Update matrices
                planetGroup.updateMatrixWorld(true);

                // Get spawn position for character height
                spawnCube.geometry.computeBoundingBox();
                const bbox = spawnCube.geometry.boundingBox;
                const cubeHeight = bbox.max.y - bbox.min.y;

                // Character height should be at the planet radius + spawn offset
                const spawnHeight = spawnLocalPos.length();
                const spawnY = spawnHeight + cubeHeight / 2 + 3.0;
                characterGroup.position.set(0, spawnY, 0);

                // Store spawn state globally for reset
                window.initialSpawnRotation = spawnRotation.clone();
                window.initialSpawnY = spawnY;

                console.log(`Character spawned at height: ${characterGroup.position.y.toFixed(2)}`);
            }

            // Hide loading screen and show intro screen after world is loaded
            const loadingScreen = document.getElementById('loading-screen');
            const introScreen = document.getElementById('intro-screen');

            // Show intro screen immediately, then fade out loading screen
            introScreen.classList.add('visible');
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 1000);
        },
        // onProgress callback
        function(xhr) {
            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');

            if (xhr.lengthComputable) {
                const percentComplete = (xhr.loaded / xhr.total) * 100;
                loadingBar.style.width = percentComplete + '%';
                loadingText.textContent = `Loading... ${Math.round(percentComplete)}%`;
                console.log(`Loading: ${Math.round(percentComplete)}% (${xhr.loaded}/${xhr.total} bytes)`);
            } else {
                // If not computable, show a loading animation instead
                const mb = (xhr.loaded / 1024 / 1024).toFixed(2);
                loadingText.textContent = `Loading... ${mb} MB`;
                console.log(`Loading: ${mb} MB (total size unknown)`);
                // Animate bar in indeterminate mode
                loadingBar.style.width = '50%';
            }
        },
        // onError callback
        function(error) {
            console.error('Error loading world model:', error);
            const loadingText = document.getElementById('loading-text');
            loadingText.textContent = 'Error loading world. Please refresh.';
            loadingText.style.color = '#ff5555';
        });

        // Character setup
        const characterGroup = new THREE.Group();
        scene.add(characterGroup);

        // Animation mixer and actions
        let mixer = null;
        let walkAction = null;
        let idleAction = null;
        let jumpAction = null;
        let characterModel = null;
        let characterLoaded = false;

        // Animation state
        const animationState = {
            isWalking: false,
            isJumping: false
        };

        // Load penguin character model
        const characterLoader = new GLTFLoader();
        characterLoader.load('manchot_the_penguin.glb', 
            function(gltf) {
                console.log('Penguin character loaded successfully!');
                characterModel = gltf.scene;
                
                // Scale the penguin to appropriate size
                characterModel.scale.set(0.075, 0.075, 0.075);
                
                // Enable shadows
                characterModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                characterGroup.add(characterModel);
                
                // Setup animation mixer
                if (gltf.animations && gltf.animations.length > 0) {
                    console.log('Found animations:', gltf.animations.map(a => a.name));
                    
                    mixer = new THREE.AnimationMixer(characterModel);
                    
                    // Try to find walk animation
                    const walkAnim = gltf.animations.find(a => 
                        a.name.toLowerCase().includes('walk') || 
                        a.name.toLowerCase().includes('run') ||
                        a.name.toLowerCase().includes('waddle')
                    ) || gltf.animations[0]; // Fallback to first animation
                    
                    // Try to find idle animation
                    const idleAnim = gltf.animations.find(a =>
                        a.name.toLowerCase().includes('idle') ||
                        a.name.toLowerCase().includes('standing')
                    );

                    // Try to find jump animation
                    const jumpAnim = gltf.animations.find(a =>
                        a.name.toLowerCase().includes('jump') ||
                        a.name.toLowerCase().includes('hop')
                    );

                    if (walkAnim) {
                        walkAction = mixer.clipAction(walkAnim);
                        walkAction.setEffectiveTimeScale(1.2); // Speed up animation
                        console.log('Walk animation set:', walkAnim.name);
                    }

                    if (idleAnim) {
                        idleAction = mixer.clipAction(idleAnim);
                        idleAction.play();
                        console.log('Idle animation set:', idleAnim.name);
                    } else if (walkAction) {
                        // If no idle, just stop walk animation when not moving
                        console.log('No idle animation found, using walk animation only');
                    }

                    if (jumpAnim) {
                        jumpAction = mixer.clipAction(jumpAnim);
                        jumpAction.setLoop(THREE.LoopOnce); // Play once per jump
                        jumpAction.clampWhenFinished = true; // Hold last frame
                        jumpAction.setEffectiveTimeScale(1.5); // Play 1x faster
                        console.log('Jump animation set:', jumpAnim.name);
                    }
                } else {
                    console.warn('No animations found in penguin model');
                }
                
                characterLoaded = true;
                console.log('Penguin character setup complete');
            }, 
            function(progress) {
                console.log('Loading penguin:', (progress.loaded / progress.total * 100).toFixed(2) + '%');
            },
            function(error) {
                console.error('Error loading penguin model:', error);
            }
        );

        // Position character at spawn height
        const characterHeight = 0.075;
        const spawnHeight = 13; // Spawn higher to ensure proper ground detection
        characterGroup.position.set(0, spawnHeight, 0);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 1.0
        });
        const starsVertices = [];
        for (let i = 0; i < 1000; i++) {
            const x = (Math.random() - 0.5) * 100;
            const y = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        planetGroup.add(stars);

        // Atmosphere
        const atmosphereGeometry = new THREE.SphereGeometry(25, 32, 32);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                sunDirection: { value: new THREE.Vector3(1, 1, 1).normalize() },
                dayColor: { value: new THREE.Color(0x87CEEB) },
                nightColor: { value: new THREE.Color(0x000000) },
                horizonColor: { value: new THREE.Color(0xFF8C00) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 sunDirection;
                uniform vec3 dayColor;
                uniform vec3 nightColor;
                uniform vec3 horizonColor;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vec3 normal = normalize(vPosition);
                    float sunAlignment = dot(normal, sunDirection);
                    float dayStrength = smoothstep(-0.3, 0.3, sunAlignment);

                    // More realistic horizon gradient - based on viewing angle
                    float horizonFade = abs(normal.y); // 0 at horizon, 1 at zenith/nadir
                    horizonFade = pow(horizonFade, 0.6); // Gentle curve for atmospheric depth

                    // Only show orange horizon during sunrise/sunset (transition periods)
                    // When dayStrength is 0.5, we're at the horizon line (sun rising/setting)
                    float transitionStrength = 1.0 - abs(dayStrength - 0.5) * 2.0; // 1.0 at sunset/sunrise, 0.0 at full day/night
                    transitionStrength = smoothstep(0.0, 0.5, transitionStrength); // Smooth the transition

                    // Horizon glow around sun (only during transitions)
                    float horizonGlow = 1.0 - abs(sunAlignment);
                    horizonGlow = pow(horizonGlow, 2.0) * transitionStrength * (1.0 - horizonFade * 0.7);

                    // Sky gradient from horizon to zenith
                    vec3 zenithColor = dayColor;
                    vec3 horizonSkyColor = mix(horizonColor, dayColor, 0.3 + (1.0 - transitionStrength) * 0.7); // Less orange during full day
                    vec3 skyColor = mix(horizonSkyColor, zenithColor, horizonFade);

                    // Blend with night
                    skyColor = mix(nightColor, skyColor, dayStrength);

                    // Add warm glow near horizon where sun is (only during transitions)
                    skyColor = mix(skyColor, horizonColor, horizonGlow * 0.6);

                    // Add sun disc directly to the atmosphere
                    float sunProximity = max(0.0, sunAlignment);
                    float sunDisc = pow(sunProximity, 150.0); // Sharp disc
                    vec3 sunColor = vec3(1.0, 0.95, 0.8); // Warm yellow-white sun
                    skyColor = mix(skyColor, sunColor, sunDisc * dayStrength);

                    // Fully opaque atmosphere
                    float alpha = dayStrength * 0.9 + 0.1;

                    gl_FragColor = vec4(skyColor, alpha);
                }
            `,
            side: THREE.BackSide,
            transparent: true,
            depthWrite: false
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Low Poly Clouds
        // Create a single low poly cloud geometry
        function createLowPolyCloud() {
            const cloud = new THREE.Group();

            // Create 3-7 spheres with low poly count for puffy cloud look
            const numPuffs = 3 + Math.floor(Math.random() * 5);

            // Random cloud width factor
            const widthFactor = 0.5 + Math.random() * 1.5; // 0.5 to 2.0x width

            for (let i = 0; i < numPuffs; i++) {
                const puffGeometry = new THREE.SphereGeometry(
                    0.3 + Math.random() * 0.5, // Random size between 0.3 and 0.8
                    6, // Low poly - 6 segments
                    5  // Low poly - 5 segments
                );

                const puffMaterial = new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    flatShading: true // Emphasize low poly look
                });

                const puff = new THREE.Mesh(puffGeometry, puffMaterial);

                // Position puffs to create cloud shape with variable width
                puff.position.x = (Math.random() - 0.5) * 1.5 * widthFactor; // Wider spread
                puff.position.y = (Math.random() - 0.5) * 0.5; // Keep height variation smaller
                puff.position.z = (Math.random() - 0.5) * 1.5 * widthFactor; // Wider spread

                cloud.add(puff);
            }

            return cloud;
        }

        // Generate multiple clouds around the planet
        const clouds = [];
        const numClouds = 150;

        for (let i = 0; i < numClouds; i++) {
            const cloud = createLowPolyCloud();

            // Variable distance from planet - creates layered cloud effect
            const baseDistance = 16.2;
            const distanceVariation = Math.random() * 3; // 0 to 3 units variation
            const cloudDistance = baseDistance + distanceVariation;

            // Random position on sphere around planet
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            cloud.position.x = cloudDistance * Math.sin(phi) * Math.cos(theta);
            cloud.position.y = cloudDistance * Math.sin(phi) * Math.sin(theta);
            cloud.position.z = cloudDistance * Math.cos(phi);

            // Look at planet center
            cloud.lookAt(0, 0, 0);

            // Random scale for variety (smaller clouds farther away)
            const distanceFactor = (cloudDistance - baseDistance) / 3; // 0 to 1
            const baseScale = 0.5 + Math.random() * 0.8;
            const scale = baseScale * (1 - distanceFactor * 0.3); // Farther clouds slightly smaller
            cloud.scale.set(scale, scale, scale);

            // Store animation data
            cloud.userData.cloudDistance = cloudDistance; // Store individual distance
            cloud.userData.rotationSpeed = (Math.random() - 0.5) * 0.001; // Slow rotation
            cloud.userData.floatOffset = Math.random() * Math.PI * 2; // Random start phase
            cloud.userData.floatSpeed = 0.0005 + Math.random() * 0.0005;
            cloud.userData.orbitSpeed = 0.00005 + Math.random() * 0.00005; // Clouds drift around planet
            cloud.userData.orbitAxis = new THREE.Vector3(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            ).normalize();

            planetGroup.add(cloud);
            clouds.push(cloud);
        }

        // Sun
        const sunDistance = 50;
        const sunRadius = 5;
        const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffdd,
            fog: false
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(10, 10, 10).normalize().multiplyScalar(sunDistance);
        planetGroup.add(sun);

        const sunGlowGeometry = new THREE.SphereGeometry(sunRadius * 1.6, 32, 32);
        const sunGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffdd99,
            transparent: true,
            opacity: 0.5,
            fog: false
        });
        const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
        sunGlow.position.copy(sun.position);
        planetGroup.add(sunGlow);

        const sunGlow2Geometry = new THREE.SphereGeometry(sunRadius * 2.2, 32, 32);
        const sunGlow2Material = new THREE.MeshBasicMaterial({
            color: 0xffbb66,
            transparent: true,
            opacity: 0.25,
            fog: false
        });
        const sunGlow2 = new THREE.Mesh(sunGlow2Geometry, sunGlow2Material);
        sunGlow2.position.copy(sun.position);
        planetGroup.add(sunGlow2);

        // Moon
        const moonDistance = 40;
        const moonRadius = 3;
        const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({
            color: 0xeeeeff,
            fog: false
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        const sunDirection = new THREE.Vector3(10, 10, 10).normalize();
        moon.position.copy(sunDirection).multiplyScalar(-moonDistance);
        planetGroup.add(moon);

        const moonGlowGeometry = new THREE.SphereGeometry(moonRadius * 1.5, 32, 32);
        const moonGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xccddff,
            transparent: true,
            opacity: 0.4,
            fog: false
        });
        const moonGlow = new THREE.Mesh(moonGlowGeometry, moonGlowMaterial);
        moonGlow.position.copy(moon.position);
        planetGroup.add(moonGlow);

        const moonLight = new THREE.PointLight(0xaabbdd, 1.0, 100); // Increased from 0.8 to 1.5
        moonLight.position.copy(moon.position);
        planetGroup.add(moonLight);

        const moonDirectionalLight = new THREE.DirectionalLight(0x8899cc, 0.3); // Increased from 0.25 to 0.6 for visible shadows
        moonDirectionalLight.position.copy(moon.position);
        moonDirectionalLight.castShadow = true; // Enable moon shadows
        moonDirectionalLight.shadow.camera.left = -30;
        moonDirectionalLight.shadow.camera.right = 30;
        moonDirectionalLight.shadow.camera.top = 30;
        moonDirectionalLight.shadow.camera.bottom = -30;
        moonDirectionalLight.shadow.camera.near = 0.5;
        moonDirectionalLight.shadow.camera.far = 150;
        moonDirectionalLight.shadow.mapSize.width = 4096; // Lower res than sun for performance
        moonDirectionalLight.shadow.mapSize.height = 4096;
        moonDirectionalLight.shadow.bias = -0.0001;
        moonDirectionalLight.shadow.normalBias = 0.02;
        moonDirectionalLight.shadow.radius = 3; // Softer shadows for moonlight
        planetGroup.add(moonDirectionalLight);

        // Cloud system
        const cloudGroup = new THREE.Group();
        planetGroup.add(cloudGroup);

        const cloudAnimations = [];
        const rainClouds = [];

        // Camera setup
        const cameraDistanceIdle = 1.2;      // Camera distance when idle (closer)
        const cameraDistanceWalking = 1.7;   // Camera distance when walking (zoomed out more)
        const cameraHeight = 1.0; // Camera vertical position
        let currentCameraDistance = cameraDistanceIdle;

        // Camera sway variables - adjust these to tune the effect
        let cameraShakeOffset = new THREE.Vector3(0, 0, 0);
        const cameraSwayIntensity = 0.003;  // Overall sway amount (increase for more movement)
        const cameraSwaySpeed = 25.0;        // Waddle rhythm speed (higher = faster sway)
        const swaySideAmount = 1;         // Side-to-side intensity multiplier
        const swayBobAmount = 0.4;          // Up-down bob intensity multiplier
        const swayRockAmount = 0;         // Forward-back rock intensity multiplier

        // Movement acceleration
        let currentMoveSpeed = 0.0;
        const maxMoveSpeed = 0.125;
        const moveAcceleration = 0.8; // Speed ramping per second
        const moveDeceleration = 1.5; // Faster stop

        camera.position.set(0, spawnHeight + cameraHeight, -cameraDistanceIdle);
        camera.lookAt(0, spawnHeight, 0);

        // Input handling
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false,
            shift: false
        };

        // Physics
        const physics = {
            velocity: new THREE.Vector3(0, 0, 0),
            gravity: 20.0,
            isGrounded: false,
            jumpForce: 5.0,
            characterRadius: 0.1,
            jumpCharging: false,
            jumpChargeTime: 0
        };

        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        let introActive = true;

        // Mouse controls for bird's eye camera
        document.addEventListener('mousedown', (e) => {
            if (e.button === 1 && !introActive) { // Middle mouse button
                e.preventDefault();

                if (!detachedCamera) {
                    // Toggle to bird's eye view - save current state
                    detachedCamera = true;

                    // Save planet rotation, character rotation, and position
                    savedPlanetRotation.copy(planetGroup.quaternion);
                    savedCharacterRotation = characterRotation;
                    savedCharacterPosition.copy(characterGroup.position);

                    // Start bird's eye rotation from current planet rotation
                    birdEyeRotation.copy(planetGroup.quaternion);

                    // Hide character
                    characterGroup.visible = false;

                    document.getElementById('camera-mode-text').textContent = 'Bird\'s Eye View - Drag to Rotate, R: Return to Player';
                    console.log('Bird\'s eye view activated - state saved');
                } else {
                    // Start dragging
                    isDragging = true;
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 1 && detachedCamera) {
                isDragging = false;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && detachedCamera && !introActive) {
                // Rotate the planet independently in bird's eye view
                const rotateSpeed = 0.005;

                // Create rotation quaternions (both reversed for natural drag feel)
                const deltaYaw = new THREE.Quaternion();
                deltaYaw.setFromAxisAngle(new THREE.Vector3(0, 1, 0), e.movementX * rotateSpeed);

                const deltaPitch = new THREE.Quaternion();
                deltaPitch.setFromAxisAngle(new THREE.Vector3(1, 0, 0), e.movementY * rotateSpeed);

                // Apply rotations to bird's eye rotation
                birdEyeRotation.multiplyQuaternions(deltaYaw, birdEyeRotation);
                birdEyeRotation.multiplyQuaternions(deltaPitch, birdEyeRotation);
            }
        });

        // Scroll wheel for zoom in bird's eye view OR FOV adjustment in normal view
        document.addEventListener('wheel', (e) => {
            if (!introActive) {
                e.preventDefault();
                if (detachedCamera) {
                    // Bird's eye view - zoom distance
                    const zoomSpeed = 0.02; // Smaller jumps for finer control
                    birdEyeDistance += e.deltaY * zoomSpeed;
                    birdEyeDistance = Math.max(8, Math.min(50, birdEyeDistance)); // Zoom range from 8 to 50 units (closer minimum)
                } else {
                    // Normal player view - adjust FOV
                    const fovSpeed = 0.05;
                    camera.fov += e.deltaY * fovSpeed;
                    camera.fov = Math.max(40, Math.min(100, camera.fov)); // FOV range from 40 to 100
                    camera.updateProjectionMatrix();
                }
            }
        }, { passive: false });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (e.key === 'Enter' && introActive) {
                introActive = false;
                document.getElementById('intro-screen').classList.add('fade-out');
                setTimeout(() => {
                    document.getElementById('intro-screen').style.display = 'none';
                }, 1000);
                return;
            }

            // Return to player with 'R' key
            if (key === 'r' && !introActive && detachedCamera) {
                detachedCamera = false;

                // Restore saved state
                planetGroup.quaternion.copy(savedPlanetRotation);
                characterRotation = savedCharacterRotation;
                characterGroup.position.copy(savedCharacterPosition);
                characterGroup.rotation.y = characterRotation;

                // Show character again
                characterGroup.visible = true;

                document.getElementById('camera-mode-text').textContent = 'Walk around the planet!';
                console.log('Returned to player-locked camera - state restored');
            }

            // Reset to spawn with 'X' key
            if (key === 'x' && !introActive) {
                // Use stored spawn position if available, otherwise use default
                const resetY = window.initialSpawnY || spawnHeight;
                characterGroup.position.set(0, resetY, 0);
                characterRotation = Math.PI;
                characterGroup.rotation.y = characterRotation;
                physics.velocity.set(0, 0, 0);
                physics.isGrounded = false;

                // Reset planet rotation to initial spawn state
                if (window.initialSpawnRotation) {
                    planetGroup.quaternion.copy(window.initialSpawnRotation);
                } else {
                    planetGroup.quaternion.set(0, 0, 0, 1);
                }

                console.log('Character reset to spawn position');
            }

            if (key in keys && !introActive) {
                keys[key] = true;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                keys.shift = true;
            }

            if (e.code === 'Space' && !introActive && physics.isGrounded && !physics.jumpCharging) {
                // Start jump charge-up
                physics.jumpCharging = true;
                physics.jumpChargeTime = 0;
                animationState.isJumping = true;

                // Play jump animation (charge-up) if available
                if (jumpAction) {
                    jumpAction.reset();
                    jumpAction.play();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                keys.shift = false;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Spotify player toggle
        window.toggleSpotify = function(event) {
            event.stopPropagation();
            event.preventDefault();

            const player = document.getElementById('spotify-player');
            const toggle = document.getElementById('spotify-toggle');

            if (player.classList.contains('minimized')) {
                player.classList.remove('minimized');
                toggle.textContent = '−';
            } else {
                player.classList.add('minimized');
                toggle.textContent = '+';
            }
        };

        // Animation loop
        const moveSpeed = 0.2; // Movement speed per second (radians)
        const turnSpeed = 2; // Turn speed per second (radians)
        let characterRotation = Math.PI; // Start rotated 180 degrees
        const dayNightSpeed = 0.025; // Day/night cycle speed
        let dayNightAngle = 0;

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update animation mixer
            if (mixer && characterLoaded) {
                mixer.update(deltaTime);

                // Check if jump animation finished and character is grounded
                if (animationState.isJumping && physics.isGrounded) {
                    animationState.isJumping = false;
                }

                // Handle jump animation (highest priority)
                if (jumpAction && animationState.isJumping) {
                    if (!jumpAction.isRunning()) {
                        // Jump animation takes priority, fade out others
                        if (walkAction && walkAction.isRunning()) walkAction.fadeOut(0.1);
                        if (idleAction && idleAction.isRunning()) idleAction.fadeOut(0.1);
                    }
                }
                // Handle walk/idle transitions (when not jumping)
                else if (walkAction && idleAction) {
                    if (animationState.isWalking) {
                        // Switch to walk
                        if (idleAction.isRunning() && !walkAction.isRunning()) {
                            idleAction.fadeOut(0.2);
                            walkAction.reset().fadeIn(0.2).play();
                        }
                    } else {
                        // Switch to idle
                        if (walkAction.isRunning() && !idleAction.isRunning()) {
                            walkAction.fadeOut(0.2);
                            idleAction.reset().fadeIn(0.2).play();
                        }
                    }
                } else if (walkAction) {
                    // Only walk animation available
                    if (animationState.isWalking) {
                        if (!walkAction.isRunning()) {
                            walkAction.play();
                        }
                    } else {
                        if (walkAction.isRunning()) {
                            walkAction.stop();
                        }
                    }
                }
            }

            // Day/night cycle
            dayNightAngle += dayNightSpeed * deltaTime;

            const sunRotationAxis = new THREE.Vector3(1, 0, 0);
            const sunBasePosition = new THREE.Vector3(10, 10, 10).normalize().multiplyScalar(sunDistance);
            sun.position.copy(sunBasePosition);
            sun.position.applyAxisAngle(sunRotationAxis, dayNightAngle);
            sunGlow.position.copy(sun.position);
            sunGlow2.position.copy(sun.position);
            sunLight.position.copy(sun.position);

            sunLight.target.position.set(0, 0, 0);
            sunLight.target.updateMatrixWorld();

            moon.position.copy(sun.position).multiplyScalar(-1);
            moonGlow.position.copy(moon.position);
            moonLight.position.copy(moon.position);
            moonDirectionalLight.position.copy(moon.position);

            moonDirectionalLight.target.position.set(0, 0, 0);
            moonDirectionalLight.target.updateMatrixWorld();

            // Update atmosphere shader with sun direction
            const sunWorldPos = new THREE.Vector3();
            sun.getWorldPosition(sunWorldPos);
            // Normalize to get direction from planet center (0,0,0) to sun
            const sunDir = sunWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).normalize();
            atmosphereMaterial.uniforms.sunDirection.value.copy(sunDir);

            // Fade stars based on sun position (day/night)
            // When sun is above horizon (y > 0), fade out stars
            const sunY = sun.position.y;
            const dayNightTransition = Math.max(0, Math.min(1, (sunY + 10) / 20)); // Smooth transition

            // Animate low poly clouds
            clouds.forEach(cloud => {
                // Store the original direction if not already stored
                if (!cloud.userData.baseDirection) {
                    cloud.userData.baseDirection = cloud.position.clone().normalize();
                }

                // Gentle floating motion - only adjust the distance, keep the direction
                const floatAmount = Math.sin(time * cloud.userData.floatSpeed + cloud.userData.floatOffset) * 0.3;
                const newDistance = cloud.userData.cloudDistance + floatAmount;

                // Update position while maintaining the base direction
                cloud.position.copy(cloud.userData.baseDirection).multiplyScalar(newDistance);

                // Orbital drift - slowly rotate the base direction
                cloud.userData.baseDirection.applyAxisAngle(cloud.userData.orbitAxis, cloud.userData.orbitSpeed);

                // Slow rotation of the cloud itself
                cloud.rotation.y += cloud.userData.rotationSpeed;

                // Hemisphere-based lighting
                // Get cloud's world position (not local to planetGroup)
                const cloudWorldPos = new THREE.Vector3();
                cloud.getWorldPosition(cloudWorldPos);
                const cloudDir = cloudWorldPos.clone().normalize();

                // Check if cloud is on day side or night side
                // Dot product: positive = day side, negative = night side
                const sunAlignment = cloudDir.dot(sunDir);

                let cloudBrightness;
                if (sunAlignment > 0) {
                    // Day hemisphere - cloud is on sun-facing side
                    // Bright white with subtle variation based on angle
                    const lightingIntensity = Math.pow(sunAlignment, 0.3); // Softer falloff
                    cloudBrightness = 0.7 + lightingIntensity * 0.3; // Range: 0.7 to 1.0
                } else {
                    // Night hemisphere - cloud is on dark side
                    cloudBrightness = 0.05; // Very dark, barely visible
                }

                // Update cloud color
                cloud.children.forEach(puff => {
                    puff.material.color.setRGB(cloudBrightness, cloudBrightness, cloudBrightness);
                });
            });

            starsMaterial.opacity = 1.0 - dayNightTransition; // 0 during day, 1 during night

            // Gameplay
            if (!introActive) {
                // Handle jump charge-up delay
                if (physics.jumpCharging) {
                    physics.jumpChargeTime += deltaTime;
                    const jumpChargeDelay = 0.3; // 300ms charge-up delay

                    if (physics.jumpChargeTime >= jumpChargeDelay) {
                        // Execute the jump after charge-up
                        physics.velocity.y = physics.jumpForce;
                        physics.isGrounded = false;
                        physics.jumpCharging = false;
                    }
                }

                // Character physics and movement (works in both modes)
                physics.velocity.y -= physics.gravity * deltaTime;
                const newY = characterGroup.position.y + physics.velocity.y * deltaTime;

                const rayOrigin = new THREE.Vector3(
                    characterGroup.position.x,
                    characterGroup.position.y,
                    characterGroup.position.z
                );

                raycaster.set(rayOrigin, downVector);
                raycaster.far = 50;

                const collisionMeshes = [];
                planetGroup.traverse((child) => {
                    if (child.isMesh) {
                        const name = child.name.toLowerCase();
                        if (!name.includes('grass') && !name.includes('pebble')) {
                            collisionMeshes.push(child);
                        }
                    }
                });

                const intersects = raycaster.intersectObjects(collisionMeshes, false);

                if (intersects.length > 0) {
                    const groundY = intersects[0].point.y;
                    const groundOffset = 0.03;
                    const targetY = groundY + groundOffset;
                    const distanceToGround = characterGroup.position.y - groundY;
                    const groundTolerance = 0.1;

                    if (distanceToGround <= groundTolerance && physics.velocity.y <= 0) {
                        characterGroup.position.y = targetY;
                        physics.velocity.y = 0;
                        physics.isGrounded = true;
                    } else {
                        characterGroup.position.y = newY;
                        physics.isGrounded = false;
                    }
                } else {
                    characterGroup.position.y = newY;
                    physics.isGrounded = false;
                }

                document.getElementById('coordinates').textContent =
                    `Position: (${characterGroup.position.x.toFixed(2)}, ${characterGroup.position.y.toFixed(2)}, ${characterGroup.position.z.toFixed(2)})`;

                characterGroup.position.x = 0;
                characterGroup.position.z = 0;

                const isTurning = keys.a || keys.d;

                if (keys.a) {
                    characterRotation += turnSpeed * deltaTime;
                }
                if (keys.d) {
                    characterRotation -= turnSpeed * deltaTime;
                }

                characterGroup.rotation.y = characterRotation;

                if (keys.w || keys.s || isTurning) {
                    animationState.isWalking = true;
                } else {
                    animationState.isWalking = false;
                }

                if (keys.w || keys.s) {
                    currentMoveSpeed = Math.min(currentMoveSpeed + moveAcceleration * deltaTime, maxMoveSpeed);
                } else {
                    currentMoveSpeed = Math.max(currentMoveSpeed - moveDeceleration * deltaTime, 0);
                }

                if (currentMoveSpeed > 0 && (keys.w || keys.s) && !detachedCamera) {
                    const direction = keys.w ? -1 : 1;

                    const forwardWorld = new THREE.Vector3(
                        Math.sin(characterRotation),
                        0,
                        Math.cos(characterRotation)
                    );

                    const rotationAxis = new THREE.Vector3().crossVectors(
                        new THREE.Vector3(0, 1, 0),
                        forwardWorld
                    ).normalize();

                    const rotation = new THREE.Quaternion();
                    rotation.setFromAxisAngle(rotationAxis, direction * currentMoveSpeed * deltaTime);

                    let collision = false;

                    const forwardRayOrigin = new THREE.Vector3(0, characterGroup.position.y, 0);
                    const forwardDirection = new THREE.Vector3(
                        -Math.sin(characterRotation) * direction,
                        0,
                        -Math.cos(characterRotation) * direction
                    );

                    const forwardRaycaster = new THREE.Raycaster(forwardRayOrigin, forwardDirection, 0, 0.2);
                    const forwardIntersects = forwardRaycaster.intersectObjects(collisionMeshes, false);

                    if (forwardIntersects.length > 0) {
                        const obstacleHeight = forwardIntersects[0].point.y;
                        const obstacleDistance = forwardIntersects[0].distance;
                        const stepHeight = obstacleHeight - (characterGroup.position.y - characterHeight);

                        if (stepHeight > 0.05 || obstacleDistance < 0.15) {
                            collision = true;
                        }
                    }

                    if (!collision) {
                        planetGroup.quaternion.multiplyQuaternions(rotation, planetGroup.quaternion);
                    }
                }

                // Camera update based on mode
                if (detachedCamera) {
                    // Bird's eye view - camera above the world with a slight tilt
                    // Apply independent bird's eye rotation to planet
                    planetGroup.quaternion.copy(birdEyeRotation);

                    // Position camera above the origin (world center) with tilt
                    const cameraHeight = birdEyeDistance * Math.cos(birdEyeTilt);
                    const cameraHorizontalOffset = birdEyeDistance * Math.sin(birdEyeTilt);

                    camera.position.set(0, cameraHeight, cameraHorizontalOffset);
                    camera.lookAt(0, 0, 0); // Look at world center
                } else {
                    // Normal player-locked camera mode - update camera position
                    const targetCameraDistance = (keys.w || keys.s) ? cameraDistanceWalking : cameraDistanceIdle;
                    const lerpFactor = 0.025;
                    currentCameraDistance = currentCameraDistance + (targetCameraDistance - currentCameraDistance) * lerpFactor;

                    // Update camera sway (natural walking motion)
                    if (animationState.isWalking && currentMoveSpeed > 0) {
                        const swayIntensity = (currentMoveSpeed / maxMoveSpeed) * cameraSwayIntensity;
                        const waddlePhase = time * cameraSwaySpeed;

                        cameraShakeOffset.x = Math.sin(waddlePhase) * swayIntensity * swaySideAmount;
                        cameraShakeOffset.y = (1 - Math.cos(waddlePhase * 2)) * swayIntensity * swayBobAmount;
                        cameraShakeOffset.z = Math.sin(waddlePhase * 0.5) * swayIntensity * swayRockAmount;
                    } else {
                        cameraShakeOffset.multiplyScalar(0.85);
                    }

                    // Update camera
                    const cameraOffsetLocal = new THREE.Vector3(0, cameraHeight, -currentCameraDistance);
                    const cameraOffsetWorld = cameraOffsetLocal.clone();
                    cameraOffsetWorld.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);

                    camera.position.copy(characterGroup.position).add(cameraOffsetWorld).add(cameraShakeOffset);

                    const lookAtOffset = new THREE.Vector3(0, characterHeight, 1);
                    lookAtOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);
                    const lookAtPoint = characterGroup.position.clone().add(lookAtOffset);
                    camera.lookAt(lookAtPoint);
                }

                // Check proximity to signs and show/hide labels
                const proximityRadius = detachedCamera ? 10.0 : 3.0; // Much larger radius in bird's eye view

                signLabels.forEach(signInfo => {
                    // Get current world position of the sign (accounts for planet rotation)
                    const signWorldPos = new THREE.Vector3();
                    signInfo.mesh.getWorldPosition(signWorldPos);

                    // Calculate distance from camera to sign in world space
                    const distance = camera.position.distanceTo(signWorldPos);

                    // Show label if within radius, hide otherwise
                    if (distance < proximityRadius) {
                        signInfo.labelObject.visible = true;

                        // Scale font size in bird's eye view
                        if (detachedCamera) {
                            signInfo.labelObject.element.style.fontSize = '20px';
                            signInfo.labelObject.element.style.padding = '10px 14px';
                        } else {
                            signInfo.labelObject.element.style.fontSize = '14px';
                            signInfo.labelObject.element.style.padding = '8px 12px';
                        }
                    } else {
                        signInfo.labelObject.visible = false;
                    }
                });
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>